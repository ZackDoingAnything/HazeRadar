<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>HazeRadar â€” Local Wind-Driven Haze Simulation</title>

<!-- Supabase JS Library -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

<!-- Bootstrap CSS for styling and layout -->
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
<!-- Leaflet CSS for the map -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>

<style>
/* Custom Dark Theme Styles using Inter font */
:root { 
    --bg:#0b1222; 
    --card:#172033; 
    --muted:#9fb2c8;
    --primary-color: #06b6d4; /* cyan-500 */
    --accent-color: #f97316; /* orange-600 */
    --text-light: #e9f7ff; /* Pure white/light color for text */
}

html, body {
    height: 100%; 
    margin: 0; 
    background: var(--bg); 
    color: var(--text-light); /* Apply light text color globally */
    font-family: Inter, Roboto, Arial, sans-serif;
}

.app {
    display: flex; 
    height: 100vh;
}

/* Sidebar Styling */
#sidebar {
    width: 350px; 
    padding: 18px; 
    border-right: 1px solid rgba(255,255,255,0.06); 
    background: #111827;
    display: flex;
    flex-direction: column;
    gap: 1rem;
    box-shadow: 2px 0 10px rgba(0,0,0,0.5);
    overflow-y: auto; /* Ensure inputs are visible */
}

#map {
    flex: 1;
}

h2 {
    font-size: 1.5rem;
    color: var(--primary-color);
    font-weight: 700;
}

/* Panel Card Styling */
.panel {
    background: var(--card); 
    padding: 16px; 
    border-radius: 12px; 
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
    border: 1px solid rgba(255,255,255,0.08);
}

/* Button Primary Overrides (for simulation) */
.btn-primary {
    background-color: var(--accent-color);
    border-color: var(--accent-color);
    font-weight: 600;
    transition: background-color 0.2s;
    border-radius: 8px;
}

.btn-primary:hover {
    background-color: #ea580c; /* darker orange */
    border-color: #ea580c;
}

/* Dropdown/Form Select Styling */
.form-select, .form-control {
    background-color: #2c3e50;
    color: var(--text-light);
    border: 1px solid rgba(255,255,255,0.15);
    border-radius: 8px;
}

.form-select:focus, .form-control:focus {
    background-color: #2c3e50;
    color: var(--text-light);
    border-color: var(--primary-color);
    box-shadow: 0 0 0 0.25rem rgba(6, 182, 212, 0.25);
}

/* Slider Panel Styling */
#sliderPanel {
    display: none;
    flex-direction: column;
    gap: 0.75rem;
}

/* Slider Track/Thumb Overrides (Minimal styling for dark theme visibility) */
#hourSlider {
    -webkit-appearance: none;
    appearance: none;
    width: 100%;
    height: 8px;
    background: rgba(255,255,255,0.1);
    border-radius: 4px;
    outline: none;
}

#hourSlider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 16px;
    height: 16px;
    background: var(--primary-color);
    border-radius: 50%;
    cursor: pointer;
    margin-top: -4px;
}

#hourSlider::-moz-range-thumb {
    width: 16px;
    height: 16px;
    background: var(--primary-color);
    border-radius: 50%;
    cursor: pointer;
    border: none;
}

/* Status/Toast Box */
.toastBox {
    font-size: 1rem; 
    margin-top: 10px; 
    color: var(--primary-color);
    font-weight: 500;
    min-height: 20px;
}

/* City Marker Styles */
.leaflet-interactive.city-marker {
    cursor: pointer;
    transition: all 0.2s ease-in-out;
}

.leaflet-interactive.city-marker:hover {
    transform: scale(1.3);
}

/* Fixed CSS for the descriptive text */
.sidebar-description {
    color: var(--text-light) !important; /* Forces the text color to white/light */
    font-size: 0.95rem;
}

/* === NEW STYLES FOR SCROLLABLE WIND DATA === */
#windForecastDisplay {
    max-height: 150px; /* Reduced fixed height */
    overflow-y: auto; /* Enable vertical scrolling */
    padding: 5px; 
    border: 1px solid #374151; 
    border-radius: 4px; 
}
/* =========================================== */

/* Responsive considerations for smaller screens */
@media (max-width: 768px) {
    .app {
        flex-direction: column;
    }
    #sidebar {
        width: 100%;
        height: auto;
        border-right: none;
        border-bottom: 1px solid rgba(255,255,255,0.06);
        box-shadow: 0 0 10px rgba(0,0,0,0.5);
    }
    #map {
        height: 50vh; 
    }
}
</style>
</head>
<body>
<div class="app">

<div id="sidebar">
Â  <h2>Wind-Driven Haze Simulation</h2>
Â  <div class="sidebar-description">A client-side model simulating 24 hours of haze spread (9 points/hour) driven by a **simulated dynamic wind forecast**, seeded by real-time data from Supabase.</div>

Â  Â  <div class="panel">
Â  Â  <strong>1. Select Starting City</strong>
Â  Â  <select id="cityDropdown" class="form-select mt-2"></select>
Â  </div>
Â  
Â  Â  <div class="panel">
Â  Â  <strong>2. Initial Wind Conditions (Supabase Fetch)</strong>
Â  Â  <div id="windForecastDisplay" class="mt-2 text-sm text-light">
Â  Â  Â  Â  Â  Â  <p class="text-center text-muted mt-2">Select a city to retrieve its initial wind data.</p>
Â  Â  </div>
Â  </div>

Â  <button id="simulateLocal" class="btn btn-primary btn-lg w-100">Run Local Wind Simulation</button>

Â  Â  <div id="sliderPanel" class="panel">
Â  Â  <strong>Timeline Control</strong>
Â  Â  <input id="hourSlider" type="range" min="1" max="24" value="1">
Â  Â  <div id="hourLabel" class="mt-2 text-center">Hour: 1</div>
Â  Â  
Â  Â  Â  Â  <div class="form-check form-switch mt-3 d-flex justify-content-center">
Â  Â  Â  Â  <input class="form-check-input" type="checkbox" id="viewModeToggle" checked>
Â  Â  Â  Â  <label class="form-check-label ms-2" for="viewModeToggle" id="toggleLabel">Cumulative View</label>
Â  Â  </div>
Â  Â  Â  Â  
Â  Â  <button id="replayBtn" class="btn btn-sm w-100 mt-2">Replay Animation</button>
Â  </div>

Â  Â  <div id="statusBox" class="toastBox">Ready.</div>
</div>

<div id="map"></div>
</div>

<!-- Leaflet JS Library -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
Â  // ------------------------------------------
Â  // --- SUPABASE INITIALIZATION ---
Â  // ------------------------------------------
Â  
Â  // Your Supabase Project URL and Public API Key
Â  const SUPABASE_URL = 'https://daxrnmvkpikjvvzgrhko.supabase.co';
Â  // NOTE: The provided key is used here.
Â  const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRheHJubXZrcGlranZ2emdyaGtvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjA2OTkyNjEsImV4cCI6MjA3NjI3NTI2MX0.XWJ_aWUh5Eci5tQSRAATqDXmQ5nh2eHQGzYu6qMcsvQ';
Â  
Â  // Initialize Supabase Client
Â  const { createClient } = supabase;
Â  const supabaseClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
Â  
Â  // ------------------------------------------
Â  // --- MAP AND CONSTANTS ---
Â  // ------------------------------------------
Â  
Â  // Endpoint to fetch the list of city coordinates
Â  const API_ROOT = "https://haze-radargnnmodelstimulation-production.up.railway.app";
Â  const map = L.map("map").setView([-1.5, 113], 5);

Â  // Use a dark tile layer for better visualization contrast
Â  L.tileLayer("https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png", {
Â  Â  maxZoom: 18,
Â  Â  attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>'
Â  }).addTo(map);

Â  let cityCoordinates = {};
Â  let cityMarkers = [];
Â  let hazeLayers = [];
Â  let predictions = [];
Â  let autoplayInterval = null;
Â  // Store 24 hours of dynamically generated wind data
Â  let hourlyWindForecast = []; 
Â  // Store the fetched base wind data for the selected city
Â  let baseWindData = null;

Â  // --- Haze Spread Constants ---
Â  const INITIAL_PM25 = 150; 
Â  const DIFFUSION_RATE = 0.03; 
Â  const HAZE_DECAY = 0.98; 
Â  
Â  // --- Radius Constants ---
Â  const MIN_RADIUS_M = 200; 
Â  const MAX_RADIUS_M = 1000; 
Â  
Â  // --- Satellite Point Offsets (Constants for randomization) ---
Â  const NUM_SATELLITES = 8; 
Â  const MAX_OFFSET_DEG = 0.04; 
Â  
Â  // --- Wind Simulation Constants (For dynamic forecast generation) ---
Â  const SPEED_VARIANCE = 5; 
Â  const DIRECTION_VARIANCE = 20; 
Â  
Â  
Â  // --- Utility Functions ---

Â  function toast(msg){ document.getElementById("statusBox").innerText = msg; }

Â  // Helper function for color interpolation (RGB)
Â  function interpolateColor(color1, color2, factor) {
Â  Â  Â  function hexToRgb(hex) {
Â  Â  Â  Â  Â  const bigint = parseInt(hex.slice(1), 16);
Â  Â  Â  Â  Â  return [(bigint >> 16) & 255, (bigint >> 8) & 255, bigint & 255];
Â  Â  Â  }
Â  Â  Â  function rgbToHex(r, g, b) {
Â  Â  Â  Â  Â  return '#' + [r, g, b].map(x => {
Â  Â  Â  Â  Â  Â  Â  const hex = Math.round(x).toString(16);
Â  Â  Â  Â  Â  Â  Â  return hex.length === 1 ? '0' + hex : hex;
Â  Â  Â  Â  Â  }).join('');
Â  Â  Â  }

Â  Â  Â  const rgb1 = hexToRgb(color1);
Â  Â  Â  const rgb2 = hexToRgb(color2);

Â  Â  Â  const r = rgb1[0] + (rgb2[0] - rgb1[0]) * factor;
Â  Â  Â  const g = rgb1[1] + (rgb2[1] - rgb1[1]) * factor;
Â  Â  Â  const b = rgb1[2] + (rgb2[2] - rgb1[2]) * factor;
Â  Â  Â  
Â  Â  Â  return rgbToHex(r, g, b);
Â  }

Â  // Define color stops: Red (1) -> Orange (8) -> Yellow (16) -> Grey (24)
Â  const COLOR_STOPS = {
Â  Â  Â  1: "#FF0000", // Red (Fresh Haze)
Â  Â  Â  8: "#FF8C00", // Dark Orange
Â  Â  Â  16: "#FFFF00", // Yellow
Â  Â  Â  24: "#808080" // Grey (Old/Muted Haze)
Â  };

Â  /**
Â  Â * Defines the color based on the forecast hour (1-24), using a gradient from Red to Grey.
Â  Â */
Â  function colorForHazePoint(h) {
Â  Â  Â  if (h <= 8) {
Â  Â  Â  Â  Â  // Red to Orange (Factor ranges from 0 to 1)
Â  Â  Â  Â  Â  const factor = (h - 1) / 7; 
Â  Â  Â  Â  Â  return interpolateColor(COLOR_STOPS[1], COLOR_STOPS[8], factor);
Â  Â  Â  } else if (h <= 16) {
Â  Â  Â  Â  Â  // Orange to Yellow (Factor ranges from 0 to 1)
Â  Â  Â  Â  Â  const factor = (h - 8) / 8;
Â  Â  Â  Â  Â  return interpolateColor(COLOR_STOPS[8], COLOR_STOPS[16], factor);
Â  Â  Â  } else {
Â  Â  Â  Â  Â  // Yellow to Grey (Factor ranges from 0 to 1)
Â  Â  Â  Â  Â  const factor = (h - 16) / 8;
Â  Â  Â  Â  Â  return interpolateColor(COLOR_STOPS[16], COLOR_STOPS[24], factor);
Â  Â  Â  }
Â  }

Â  /**
Â  Â * Defines the radius in meters for the leaflet circle marker based on PM2.5 level.
Â  Â */
Â  function radiusForPM(pm25){ 
Â  Â  return Math.max(MIN_RADIUS_M, (pm25 / INITIAL_PM25) * MAX_RADIUS_M); 
Â  }

Â  function clearHaze(){
Â  Â  hazeLayers.forEach(l => map.removeLayer(l));
Â  Â  hazeLayers = [];
Â  }
Â  
Â  function clearMarkers() {
Â  Â  cityMarkers.forEach(l => map.removeLayer(l));
Â  Â  cityMarkers = [];
Â  }
Â  
Â  // ----------------------------------------------------
Â  // --- Supabase Fetch for Initial Wind (Hour 1) ---
Â  // ----------------------------------------------------
Â  
Â  /**
Â  Â * Fetches the latest wind speed and direction for the selected city from Supabase.
Â  Â */
Â  async function fetchInitialWindData(cityName) {
Â  Â  Â  toast(`Fetching initial wind data for ${cityName} from Supabase...`);
Â  Â  Â  baseWindData = null; // Clear previous data

Â  Â  Â  // Supabase query to get the latest wind data for the selected city
Â  Â  Â  const { data, error } = await supabaseClient
Â  Â  Â  Â  .from('gnn_training_data') // Your specified table name
Â  Â  Â  Â  .select('wind_speed, wind_direction, timestamp') 
Â  Â  Â  Â  .eq('city', cityName)
Â  Â  Â  Â  .order('timestamp', { ascending: false }) 
Â  Â  Â  Â  .limit(1)

Â  Â  Â  if (error) {
Â  Â  Â  Â  Â  console.error("Supabase Error:", error);
Â  Â  Â  Â  Â  document.getElementById("windForecastDisplay").innerHTML = `
Â  Â  Â  Â  Â  Â  Â <p class="text-danger text-center mt-2">Error: Could not fetch wind data from Supabase. Check console.</p>
Â  Â  Â  Â  Â  `;
Â  Â  Â  Â  Â  toast(`Supabase Error: ${error.message}`);
Â  Â  Â  Â  Â  return false;
Â  Â  Â  }

Â  Â  Â  if (data && data.length > 0) {
Â  Â  Â  Â  Â  const wind = data[0];
Â  Â  Â  Â  Â  baseWindData = { 
Â  Â  Â  Â  Â  Â  speed: wind.wind_speed, 
Â  Â  Â  Â  Â  Â  direction: wind.wind_direction 
Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  document.getElementById("windForecastDisplay").innerHTML = `
Â  Â  Â  Â  Â  Â  Â  <p class="mb-0 mt-1">
Â  Â  Â  Â  Â  Â  Â  Â  <span class="font-weight-bold">Speed:</span> ${baseWindData.speed} km/h (Hour 1, Fetched)
Â  Â  Â  Â  Â  Â  Â  </p>
Â  Â  Â  Â  Â  Â  Â  <p class="mb-0">
Â  Â  Â  Â  Â  Â  Â  Â  <span class="font-weight-bold">Direction:</span> ${baseWindData.direction}Â° (Hour 1, Fetched)
Â  Â  Â  Â  Â  Â  Â  </p>
Â  Â  Â  Â  Â  Â  Â  <p class="text-muted text-xs mt-1 mb-0">Run simulation to generate Hour 2-24 forecast.</p>
Â  Â  Â  Â  Â  `;
Â  Â  Â  Â  Â  toast(`Wind data loaded for ${cityName}.`);
Â  Â  Â  Â  Â  return true;
Â  Â  Â  } else {
Â  Â  Â  Â  Â  document.getElementById("windForecastDisplay").innerHTML = `
Â  Â  Â  Â  Â  Â  Â <p class="text-warning text-center mt-2">No latest wind data found for ${cityName} in gnn_training_data.</p>
Â  Â  Â  Â  Â  `;
Â  Â  Â  Â  Â  toast(`No wind data found for ${cityName}.`);
Â  Â  Â  Â  Â  return false;
Â  Â  Â  }
Â  }

Â  // ----------------------------------------------------
Â  // --- Dynamic Wind Forecast Generator (Hours 2-24) ---
Â  // ----------------------------------------------------

Â  /**
Â  Â * Generates a 24-hour wind forecast with hourly variations, seeded by the base data.
Â  Â */
Â  function generateDynamicWindForecastFromBase() {
Â  Â  Â  hourlyWindForecast = [];
Â  Â  Â  
Â  Â  Â  // Hour 1: Use the fetched base data directly
Â  Â  Â  hourlyWindForecast.push({
Â  Â  Â  Â  Â  hour: 1,
Â  Â  Â  Â  Â  speed: parseFloat(baseWindData.speed),
Â  Â  Â  Â  Â  direction: parseFloat(baseWindData.direction)
Â  Â  Â  });

Â  Â  Â  let currentSpeed = baseWindData.speed;
Â  Â  Â  let currentDirection = baseWindData.direction;

Â  Â  Â  // Hours 2 through 24: Generate dynamically
Â  Â  Â  for (let h = 2; h <= 24; h++) {
Â  Â  Â  Â  Â  // Randomly adjust speed
Â  Â  Â  Â  Â  const speedChange = (Math.random() - 0.5) * 2 * SPEED_VARIANCE; // +/- variance
Â  Â  Â  Â  Â  currentSpeed = Math.max(5, currentSpeed + speedChange); // Keep min speed 5 km/h

Â  Â  Â  Â  Â  // Randomly adjust direction (wrap around 0-360)
Â  Â  Â  Â  Â  const directionChange = (Math.random() - 0.5) * 2 * DIRECTION_VARIANCE; // +/- variance
Â  Â  Â  Â  Â  currentDirection = (currentDirection + directionChange) % 360;
Â  Â  Â  Â  Â  if (currentDirection < 0) currentDirection += 360;
Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  const windData = {
Â  Â  Â  Â  Â  Â  Â  hour: h,
Â  Â  Â  Â  Â  Â  Â  speed: parseFloat(currentSpeed.toFixed(1)),
Â  Â  Â  Â  Â  Â  Â  direction: Math.floor(currentDirection)
Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  hourlyWindForecast.push(windData);
Â  Â  Â  }
Â  Â  Â  
Â  Â  Â  // Update the display to show the full dynamic forecast in the scrollable box
Â  Â  Â  let html = '<strong>Generated Hourly Wind Data:</strong><ul class="list-unstyled text-xs p-1 m-0">';
Â  Â  Â  hourlyWindForecast.forEach(w => {
Â  Â  Â  Â  Â  // Highlight Hour 1 (fetched data)
Â  Â  Â  Â  Â  const isFetched = w.hour === 1 ? ' font-weight-bold text-success' : '';
Â  Â  Â  Â  Â  html += `<li class="d-flex justify-content-between${isFetched}"><span>Hour ${w.hour.toString().padStart(2, '0')}:</span> <span>${w.speed} km/h @ ${w.direction}Â°</span></li>`;
Â  Â  Â  });
Â  Â  Â  html += '</ul>';
Â  Â  Â  document.getElementById("windForecastDisplay").innerHTML = html;
Â  }

Â  // --- CORE LOGIC: Local Wind-Driven Simulation ---

Â  /**
Â  Â * Simulates the movement and spread of a haze cloud over 24 hours.
Â  Â */
Â  function simulateLocalHazeSpread(centerLat, centerLon) {
Â  Â  Â  console.log(`Starting local simulation from Lat: ${centerLat}, Lon: ${centerLon}`);
Â  Â  Â  
Â  Â  Â  const results = [];
Â  Â  Â  const DEGREE_PER_KMH = 0.00005; // Conversion factor for movement
Â  Â  Â  
Â  Â  Â  // Initial plume center is the initial fire coordinate (hour 0).
Â  Â  Â  let currentPlumeCenterLat = centerLat;
Â  Â  Â  let currentPlumeCenterLon = centerLon;
Â  Â  Â  let currentPM25 = INITIAL_PM25;

Â  Â  Â  for (let h = 1; h <= 24; h++) {
Â  Â  Â  Â  Â  const wind = hourlyWindForecast[h - 1]; // Get wind data for the current hour
Â  Â  Â  Â  Â  const windSpeed = wind.speed;
Â  Â  Â  Â  Â  const windDirDeg = wind.direction;
Â  Â  Â  Â  Â  const windRad = windDirDeg * (Math.PI / 180);
Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  // 1. Calculate new plume center location for THIS hour
Â  Â  Â  Â  Â  const hourlyWindShift = windSpeed * DEGREE_PER_KMH;
Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  // Calculate the new central location of the haze plume
Â  Â  Â  Â  Â  const nextPlumeCenterLat = currentPlumeCenterLat + hourlyWindShift * Math.cos(windRad);
Â  Â  Â  Â  Â  const nextPlumeCenterLon = currentPlumeCenterLon + hourlyWindShift * Math.sin(windRad);
Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  // Update the plume center for the next iteration
Â  Â  Â  Â  Â  currentPlumeCenterLat = nextPlumeCenterLat;
Â  Â  Â  Â  Â  currentPlumeCenterLon = nextPlumeCenterLon;


Â  Â  Â  Â  Â  // 2. Update Haze Intensity
Â  Â  Â  Â  Â  currentPM25 *= HAZE_DECAY;
Â  Â  Â  Â  Â  let basePM25 = currentPM25 + (Math.random() - 0.5) * 5; // Add noise
Â  Â  Â  Â  Â  if (basePM25 < 5) basePM25 = 5; // Clamp min PM2.5
Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  // 3. Add Core Point (The heaviest point of the plume)
Â  Â  Â  Â  Â  results.push({
Â  Â  Â  Â  Â  Â  Â  latitude: currentPlumeCenterLat,
Â  Â  Â  Â  Â  Â  Â  longitude: currentPlumeCenterLon,
Â  Â  Â  Â  Â  Â  Â  predicted_pm25: basePM25 * 1.05, // Core is slightly denser
Â  Â  Â  Â  Â  Â  Â  forecast_hour: h
Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  // 4. Add Satellite Points (The dispersed cluster - now randomized)
Â  Â  Â  Â  Â  for (let i = 0; i < NUM_SATELLITES; i++) {
Â  Â  Â  Â  Â  Â  Â  // Diffusion spreads relative to the current plume center
Â  Â  Â  Â  Â  Â  Â  const dispersionFactor = h * DIFFUSION_RATE;
Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  // Generate random angle (0 to 2*PI) and random distance (0 to Max possible spread)
Â  Â  Â  Â  Â  Â  Â  const randomAngle = Math.random() * 2 * Math.PI;
Â  Â  Â  Â  Â  Â  Â  const maxDist = MAX_OFFSET_DEG * dispersionFactor;
Â  Â  Â  Â  Â  Â  Â  const randomDist = Math.random() * maxDist; 
Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  const satelliteLat = currentPlumeCenterLat + randomDist * Math.cos(randomAngle);
Â  Â  Â  Â  Â  Â  Â  const satelliteLon = currentPlumeCenterLon + randomDist * Math.sin(randomAngle);
Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  const satellitePM25 = basePM25 * (0.8 + Math.random() * 0.2); 

Â  Â  Â  Â  Â  Â  Â  results.push({
Â  Â  Â  Â  Â  Â  Â  Â  Â  latitude: satelliteLat,
Â  Â  Â  Â  Â  Â  Â  Â  Â  longitude: satelliteLon,
Â  Â  Â  Â  Â  Â  Â  Â  Â  predicted_pm25: satellitePM25,
Â  Â  Â  Â  Â  Â  Â  Â  Â  forecast_hour: h
Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  Â  
Â  Â  Â  console.log(`Local simulation generated ${results.length} predictions.`);
Â  Â  Â  return results;
Â  }
Â  
Â  // --- City Loading Logic ---

Â  /**
Â  Â * Loads cities from the API, populates the dropdown, and draws the initial city dots.
Â  Â */
Â  async function loadCities() {
Â  Â  try {
Â  Â  Â  // Fetch list of cities from the external API (not Supabase)
Â  Â  Â  const r = await fetch(API_ROOT + "/api/cities");
Â  Â  Â  
Â  Â  Â  if (!r.ok) {
Â  Â  Â  Â  Â toast(`Error loading cities: Status ${r.status}`);
Â  Â  Â  Â  Â throw new Error(`HTTP error! status: ${r.status}`);
Â  Â  Â  }
Â  Â  Â  
Â  Â  Â  const d = await r.json();

Â  Â  Â  const dropdown = document.getElementById("cityDropdown");
Â  Â  Â  dropdown.innerHTML = "";
Â  Â  Â  
Â  Â  Â  if (!d.cities || d.cities.length === 0) {
Â  Â  Â  Â  toast("Error: Could not load cities from API.");
Â  Â  Â  Â  return;
Â  Â  Â  }

Â  Â  Â  clearMarkers(); 
Â  Â  Â  clearHaze(); 

Â  Â  Â  d.cities.forEach(c => {
Â  Â  Â  Â  cityCoordinates[c.city] = c;
Â  Â  Â  Â  
Â  Â  Â  Â  const opt = document.createElement("option");
Â  Â  Â  Â  opt.value = c.city;
Â  Â  Â  Â  opt.innerText = c.city;
Â  Â  Â  Â  dropdown.appendChild(opt);

Â  Â  Â  Â  // Create city marker on the map
Â  Â  Â  Â  const marker = L.circleMarker([c.latitude, c.longitude], {
Â  Â  Â  Â  Â  radius:8, 
Â  Â  Â  Â  Â  color:"#06b6d4", 
Â  Â  Â  Â  Â  fillColor:"#22d3ee",
Â  Â  Â  Â  Â  fillOpacity:0.8,
Â  Â  Â  Â  Â  weight:1,
Â  Â  Â  Â  Â  className: 'city-marker'
Â  Â  Â  Â  }).addTo(map);

Â  Â  Â  Â  marker.bindPopup(`<b>${c.city}</b><br>Initial Haze Source Point.`);
Â  Â  Â  Â  cityMarkers.push(marker);
Â  Â  Â  });
Â  Â  Â  
Â  Â  Â  // Select the first city and fetch its initial wind data
Â  Â  Â  const initialCity = dropdown.value;
Â  Â  Â  if(initialCity) {
Â  Â  Â  Â  Â  await fetchInitialWindData(initialCity);
Â  Â  Â  }
Â  Â  Â  
Â  Â  Â  toast(`Cities loaded. Simulation is ready.`);
Â  Â  Â  
Â  Â  } catch (error) {
Â  Â  Â  console.error("Error loading cities:", error);
Â  Â  Â  toast(`Error loading cities. Please check the network connection. (${error.message})`);
Â  Â  }
Â  }

Â  /**
Â  Â * Runs the local simulation and initiates the animation.
Â  Â */
Â  function runSimulation(){
Â  Â  const selectedCity = document.getElementById("cityDropdown").value;
Â  Â  const c = cityCoordinates[selectedCity];

Â  Â  if (!c || !baseWindData) {
Â  Â  Â  Â  toast("Please select a city and wait for initial wind data to load.");
Â  Â  Â  Â  return;
Â  Â  }

Â  Â  if (autoplayInterval) {
Â  Â  Â  Â  clearInterval(autoplayInterval);
Â  Â  Â  Â  autoplayInterval = null;
Â  Â  }

Â  Â  clearHaze();
Â  Â  toast(`Running local wind simulation from ${selectedCity} with dynamic forecast... ðŸ’¨`);

Â  Â  // --- EXECUTE LOCAL MODEL ---
Â  Â  // Generate the full dynamic forecast using the fetched base data as the seed
Â  Â  generateDynamicWindForecastFromBase();
Â  Â  predictions = simulateLocalHazeSpread(c.latitude, c.longitude);
Â  Â  // ---------------------------
Â  Â  
Â  Â  // Zoom in on the selected city
Â  Â  map.flyTo([c.latitude, c.longitude], 13, {animate:true, duration:1.5}); 
Â  Â  
Â  Â  if (predictions.length > 0) {
Â  Â  Â  Â  toast("Simulation complete. Playing haze spread... ðŸŒ¬ï¸");
Â  Â  Â  Â  playAnimation();
Â  Â  } else {
Â  Â  Â  Â  toast("Local simulation failed to generate data.");
Â  Â  }
Â  }

Â  /**
Â  Â * Starts the 24-hour animation loop (like a video player).
Â  Â */
Â  function playAnimation(){
Â  Â  clearHaze();
Â  Â  let hour=1;
Â  Â  document.getElementById("sliderPanel").style.display = "flex"; // Show controls

Â  Â  // Clear any existing interval before starting a new one
Â  Â  if (autoplayInterval) {
Â  Â  Â  Â  clearInterval(autoplayInterval);
Â  Â  }
Â  Â  
Â  Â  showHour(hour); // Show hour 1 immediately
Â  Â  hour++;

Â  Â  autoplayInterval = setInterval(()=>{
Â  Â  Â  showHour(hour);
Â  Â  Â  hour++;
Â  Â  Â  if(hour>24){
Â  Â  Â  Â  clearInterval(autoplayInterval);
Â  Â  Â  Â  autoplayInterval = null;
Â  Â  Â  Â  toast("Playback finished. Use slider to inspect manually.");
Â  Â  Â  }
Â  Â  }, 800); // 800ms per hour step
Â  }

Â  /**
Â  Â * Draws the prediction data for a specific hour based on the toggle view mode.
Â  Â */
Â  function showHour(h){
Â  Â  clearHaze();
Â  Â  document.getElementById("hourSlider").value = h;
Â  Â  document.getElementById("hourLabel").innerText = "Hour: "+h;
Â  Â  
Â  Â  // Determine view mode based on the toggle state
Â  Â  const isCumulative = document.getElementById("viewModeToggle").checked;
Â  Â  
Â  Â  // Filter logic: show up to 'h' for cumulative, or ONLY 'h' for hourly
Â  Â  const hourData = predictions.filter(p => 
Â  Â  Â  Â  isCumulative ? p.forecast_hour <= h : p.forecast_hour === h
Â  Â  );

Â  Â  hourData.forEach(p => {
Â  Â  Â  const pm25 = p.predicted_pm25; 
Â  Â  Â  const col = colorForHazePoint(p.forecast_hour);
Â  Â  Â  const dynamicRadius = radiusForPM(pm25); 

Â  Â  Â  // Draw a circle for each predicted point
Â  Â  Â  const ring = L.circle([p.latitude, p.longitude],{
Â  Â  Â  Â  radius:dynamicRadius, 
Â  Â  Â  Â  color:col,
Â  Â  Â  Â  fillColor:col,
Â  Â  Â  Â  fillOpacity:0.25, 
Â  Â  Â  Â  weight:0 
Â  Â  Â  }).addTo(map);

Â  Â  Â  // Add popup with details for inspection
Â  Â  Â  ring.bindPopup(`
Â  Â  Â  Â  Â  <b>Hour ${p.forecast_hour} Prediction</b><br>
Â  Â  Â  Â  Â  PM2.5: ${p.predicted_pm25.toFixed(2)} Âµg/mÂ³<br>
Â  Â  Â  Â  Â  Wind: ${hourlyWindForecast[p.forecast_hour - 1].speed} km/h @ ${hourlyWindForecast[p.forecast_hour - 1].direction}Â°
Â  Â  Â  `);

Â  Â  Â  hazeLayers.push(ring);
Â  Â  });
Â  }

Â  // --- Event Handlers ---

Â  document.getElementById("simulateLocal").onclick = runSimulation;

Â  document.getElementById("cityDropdown").addEventListener("change", async e => {
Â  Â  const selectedCity = e.target.value;
Â  Â  const c = cityCoordinates[selectedCity];
Â  Â  
Â  Â  clearHaze();
Â  Â  
Â  Â  const fetchSuccess = await fetchInitialWindData(selectedCity);

Â  Â  if (c) {
Â  Â  Â  Â  // Zoom in on the selected city
Â  Â  Â  Â  map.flyTo([c.latitude, c.longitude], 13, { duration: 1.0 });
Â  Â  }
Â  });
Â  
Â  // Toggle handler for view mode
Â  document.getElementById("viewModeToggle").addEventListener("change", e => {
Â  Â  Â  const isChecked = e.target.checked;
Â  Â  Â  document.getElementById("toggleLabel").innerText = isChecked ? "Cumulative View" : "Hourly View";
Â  Â  Â  
Â  Â  Â  // Re-render the current hour based on the new view mode
Â  Â  Â  const currentHour = parseInt(document.getElementById("hourSlider").value);
Â  Â  Â  if (predictions.length > 0) {
Â  Â  Â  Â  Â  showHour(currentHour);
Â  Â  Â  }
Â  Â  Â  
Â  Â  Â  // Stop autoplay if running
Â  Â  Â  if (autoplayInterval) {
Â  Â  Â  Â  Â  clearInterval(autoplayInterval);
Â  Â  Â  Â  Â  autoplayInterval = null;
Â  Â  Â  Â  Â  toast(`Autoplay paused. Switched to ${isChecked ? 'Cumulative' : 'Hourly'} View.`);
Â  Â  Â  }
Â  });


Â  // Handle slider interaction (stops autoplay)
Â  document.getElementById("hourSlider").addEventListener("input", e=>{
Â  Â  if (autoplayInterval) {
Â  Â  Â  Â  clearInterval(autoplayInterval);
Â  Â  Â  Â  autoplayInterval = null;
Â  Â  Â  Â  toast("Autoplay paused. Inspecting manually.");
Â  Â  }
Â  Â  if (predictions.length > 0) {
Â  Â  Â  Â  showHour(parseInt(e.target.value));
Â  Â  } else {
Â  Â  Â  Â  document.getElementById("hourLabel").innerText = "Hour: "+e.target.value;
Â  Â  }
Â  });

Â  // Replay button handler
Â  document.getElementById("replayBtn").onclick = ()=>{
Â  Â  if (predictions.length > 0) {
Â  Â  Â  Â  playAnimation();
Â  Â  Â  Â  toast("Replaying simulation... ðŸ’¨");
Â  Â  } else {
Â  Â  Â  Â  toast("Please run a simulation first.");
Â  Â  }
Â  };

Â  // --- Initialization ---
Â  loadCities();
</script>
</body>
</html>